<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N2K Data Simulator</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        .card h2 {
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            padding-bottom: 10px;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        .label { font-weight: bold; }
        .value { font-family: 'Courier New', monospace; }
        button {
            width: 100%;
            padding: 12px 24px;
            margin: 10px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-start { background: #4CAF50; color: white; }
        .btn-start:hover { background: #45a049; }
        .btn-stop { background: #f44336; color: white; }
        .btn-stop:hover { background: #da190b; }
        .btn-reset { background: #FF9800; color: white; }
        .btn-reset:hover { background: #e68900; }
        .btn-mode { background: #2196F3; color: white; }
        .btn-mode:hover { background: #0b7dda; }
        .btn-mode.active { background: #ff9800; }
        .btn-mode:disabled { background: #555; opacity: 0.5; cursor: not-allowed; }
        .status {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }
        .status.running { background: #4CAF50; }
        .status.stopped { background: #f44336; }
        .anchor-widgets-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        @media (max-width: 900px) {
            .anchor-widgets-row {
                grid-template-columns: 1fr;
            }
        }
        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            background: rgba(0,0,0,0.2);
            color: white;
            font-size: 14px;
        }
        #map {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .leaflet-container {
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öì N2K Data Simulator</h1>

        <div class="grid">
            <div class="card">
                <h2>Control</h2>
                <div class="info-row">
                    <span class="label">Status:</span>
                    <span class="status stopped" id="status">STOPPED</span>
                </div>
                <button class="btn-start" onclick="startSimulator()">‚ñ∂ Start</button>
                <button class="btn-stop" onclick="stopSimulator()">‚èπ Stop</button>
                <button class="btn-reset" onclick="resetSimulator()">üîÑ Reset</button>
                <button class="btn-mode" onclick="toggleSettings()" style="margin-top: 10px; width: 100%;">‚öôÔ∏è Settings</button>

                <div id="settings-panel" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                    <h3 style="margin: 0 0 15px 0; font-size: 1.1em;">Simulator Settings</h3>

                    <label>Update Frequency:</label>
                    <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="range" id="update-rate-slider" min="0.1" max="10" step="0.1" value="2.0"
                               style="flex: 1;" oninput="updateRateDisplay()">
                        <span id="update-rate-display" style="min-width: 60px; text-align: right;">2.0 Hz</span>
                    </div>
                    <p style="font-size: 0.85em; opacity: 0.7; margin: 5px 0 15px 0;">
                        Controls NMEA sentence broadcast rate (0.1 to 10 Hz)
                    </p>

                    <h3 style="margin: 20px 0 15px 0; font-size: 1.1em;">‚öì Anchoring Settings</h3>

                    <label>Anchor Rode Distance (meters):</label>
                    <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="number" id="anchor-rode-distance" value="50" step="5" min="10" max="300"
                               style="flex: 1; padding: 8px; background: #2a2a2a; color: white; border: 1px solid #444; border-radius: 5px;">
                        <span style="min-width: 40px;">m</span>
                    </div>
                    <p style="font-size: 0.85em; opacity: 0.7; margin: 5px 0 15px 0;">
                        Maximum distance boat can drift from anchor (scope length)
                    </p>

                    <h3 style="margin: 20px 0 15px 0; font-size: 1.1em;">üì° Additional PGNs</h3>
                    <p style="font-size: 0.85em; opacity: 0.7; margin: 0 0 15px 0;">
                        Garmin CCU / MC10 compatible PGNs
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 15px;">
                        <label style="display: flex; align-items: center; gap: 10px; opacity: 0.5; cursor: not-allowed;">
                            <input type="checkbox" id="pgn-depth" disabled style="width: 20px; height: 20px; cursor: not-allowed;">
                            <span>Depth (PGN 128267)</span>
                        </label>

                        <label style="display: flex; align-items: center; gap: 10px; opacity: 0.5; cursor: not-allowed;">
                            <input type="checkbox" id="pgn-water-speed" disabled style="width: 20px; height: 20px; cursor: not-allowed;">
                            <span>Water Speed (PGN 128259)</span>
                        </label>

                        <label style="display: flex; align-items: center; gap: 10px; opacity: 0.5; cursor: not-allowed;">
                            <input type="checkbox" id="pgn-water-temp" disabled style="width: 20px; height: 20px; cursor: not-allowed;">
                            <span>Water Temperature (PGN 130316)</span>
                        </label>
                    </div>

                    <p style="font-size: 0.8em; opacity: 0.5; margin: 0 0 15px 0; font-style: italic;">
                        Coming soon - data transmission parameters will be defined
                    </p>

                    <button class="btn-mode" onclick="applySettings()" style="width: 100%;">Apply Settings</button>
                </div>
            </div>

            <div class="card">
                <h2>Current Position</h2>
                <div class="info-row">
                    <span class="label">Latitude:</span>
                    <span class="value" id="lat">--.------</span>
                </div>
                <div class="info-row">
                    <span class="label">Longitude:</span>
                    <span class="value" id="lon">--.------</span>
                </div>
                <div class="info-row">
                    <span class="label">Speed:</span>
                    <span class="value" id="speed">0.0 m/s</span>
                </div>
                <div class="info-row">
                    <span class="label">Course:</span>
                    <span class="value" id="course">0.0¬∞</span>
                </div>
            </div>

            <div class="card">
                <h2>Network</h2>
                <div class="info-row">
                    <span class="label">Hostname:</span>
                    <span class="value" id="hostname">-</span>
                </div>
                <div class="info-row">
                    <span class="label">UDP Port:</span>
                    <span class="value" id="udp-port">2000</span>
                </div>
                <div class="info-row">
                    <span class="label">TCP Port:</span>
                    <span class="value" id="tcp-port">10110</span>
                </div>
                <div class="info-row">
                    <span class="label">TCP Clients:</span>
                    <span class="value" id="tcp-clients">0</span>
                </div>
            </div>

            <div class="card">
                <h2>‚öì Wind Conditions</h2>
                <div class="info-row">
                    <span class="label">Wind Speed:</span>
                    <span class="value" id="wind-speed">0.0 kts</span>
                </div>
                <div class="info-row">
                    <span class="label">Wind Direction:</span>
                    <span class="value" id="wind-dir">0¬∞</span>
                </div>
                <label>Speed (knots):</label>
                <input type="number" id="wind-speed-input" value="0" step="0.5" min="0" max="40" onkeypress="if(event.key==='Enter'){event.preventDefault(); applyWind();}">
                <label>Direction (degrees):</label>
                <input type="number" id="wind-dir-input" value="0" step="5" min="0" max="359" onkeypress="if(event.key==='Enter'){event.preventDefault(); applyWind();}">
                <button class="btn-mode" onclick="applyWind()">Apply Wind</button>

                <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="variable-wind" onchange="toggleVariableWind()" style="width: 20px; height: 20px;">
                        <span>Variable Wind</span>
                    </label>
                    <p style="font-size: 0.85em; opacity: 0.7; margin: 8px 0 0 0;">
                        Speed varies up to 20 knots, direction ¬±30¬∞ every 30s
                    </p>
                </div>
            </div>

            <div class="card" id="drift-settings-widget" style="display: none;">
                <h2>üåä Drift Settings</h2>
                <p style="font-size: 0.9em; opacity: 0.8; margin: 0 0 15px 0;">
                    No wind detected - specify drift manually
                </p>
                <div class="info-row">
                    <span class="label">Current Drift:</span>
                    <span class="value" id="drift-status">Not set</span>
                </div>
                <label>Drift Direction (degrees):</label>
                <input type="number" id="manual-drift-dir" value="0" step="5" min="0" max="359" onkeyup="if(event.key==='Enter'){applyManualDrift();}">
                <small style="opacity: 0.7; display: block; margin: 5px 0 10px 0;">Direction boat is drifting TO (0=North, 90=East, 180=South, 270=West)</small>

                <label>Drift Speed (knots):</label>
                <input type="number" id="manual-drift-speed" value="0.5" step="0.1" min="0" max="5" onkeyup="if(event.key==='Enter'){applyManualDrift();}">
                <small style="opacity: 0.7; display: block; margin: 5px 0 10px 0;">Typical current drift: 0.5-2 knots</small>

                <button class="btn-mode" onclick="applyManualDrift()">Apply Drift</button>
            </div>

            <div class="card">
                <h2>üß≠ Magnetic Compass</h2>
                <div style="display: flex; flex-direction: column; align-items: center; gap: 15px;">
                    <svg id="compass-svg" width="240" height="240" viewBox="0 0 240 240" style="filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
                        <!-- Outer wind ring background -->
                        <circle cx="120" cy="120" r="110" fill="none" stroke="rgba(33,150,243,0.3)" stroke-width="1.5" stroke-dasharray="4,4"/>

                        <!-- Wind angle arc indicator (will be updated dynamically) -->
                        <g id="wind-indicator">
                            <path id="wind-arc" d="" fill="none" stroke="rgba(33,150,243,0.6)" stroke-width="3" stroke-linecap="round"/>
                            <circle id="wind-arrow-tip" cx="120" cy="10" r="4" fill="#2196F3"/>
                        </g>

                        <!-- Compass background circle -->
                        <circle cx="120" cy="120" r="90" fill="rgba(255,255,255,0.1)" stroke="rgba(255,255,255,0.3)" stroke-width="2"/>

                        <!-- Cardinal direction markers -->
                        <g id="compass-rose" transform-origin="120 120" style="transition: transform 0.3s ease-out;">
                            <!-- North marker (red) -->
                            <path d="M 120 40 L 125 55 L 120 50 L 115 55 Z" fill="#ff4444" stroke="#fff" stroke-width="1"/>
                            <text x="120" y="38" text-anchor="middle" fill="#ff4444" font-size="16" font-weight="bold" font-family="Arial">N</text>

                            <!-- East marker -->
                            <text x="195" y="125" text-anchor="middle" fill="rgba(255,255,255,0.7)" font-size="14" font-weight="bold" font-family="Arial">E</text>
                            <circle cx="190" cy="120" r="3" fill="rgba(255,255,255,0.5)"/>

                            <!-- South marker -->
                            <text x="120" y="208" text-anchor="middle" fill="rgba(255,255,255,0.7)" font-size="14" font-weight="bold" font-family="Arial">S</text>
                            <circle cx="120" cy="200" r="3" fill="rgba(255,255,255,0.5)"/>

                            <!-- West marker -->
                            <text x="48" y="125" text-anchor="middle" fill="rgba(255,255,255,0.7)" font-size="14" font-weight="bold" font-family="Arial">W</text>
                            <circle cx="50" cy="120" r="3" fill="rgba(255,255,255,0.5)"/>

                            <!-- Degree markers every 30 degrees -->
                            <g fill="rgba(255,255,255,0.4)" font-size="10" font-family="Arial">
                                <text x="168" y="60" text-anchor="middle">60</text>
                                <text x="185" y="95" text-anchor="middle">90</text>
                                <text x="168" y="185" text-anchor="middle">150</text>
                                <text x="120" y="195" text-anchor="middle">180</text>
                                <text x="72" y="185" text-anchor="middle">210</text>
                                <text x="55" y="150" text-anchor="middle">240</text>
                                <text x="72" y="60" text-anchor="middle">330</text>
                            </g>
                        </g>

                        <!-- Center dot -->
                        <circle cx="120" cy="120" r="5" fill="#fff" stroke="rgba(0,0,0,0.5)" stroke-width="1"/>

                        <!-- Wind data on outer ring -->
                        <g id="wind-data">
                            <!-- TWS (True Wind Speed) - Top -->
                            <text x="120" y="20" text-anchor="middle" fill="#2196F3" font-size="11" font-weight="bold" font-family="Arial">TWS</text>
                            <text x="120" y="32" text-anchor="middle" fill="#2196F3" font-size="13" font-weight="bold" font-family="Arial" id="tws-value">0.0</text>

                            <!-- Wind Angle - Bottom -->
                            <text x="120" y="222" text-anchor="middle" fill="#2196F3" font-size="11" font-weight="bold" font-family="Arial">ANGLE</text>
                            <text x="120" y="234" text-anchor="middle" fill="#2196F3" font-size="13" font-weight="bold" font-family="Arial" id="wind-angle-value">0¬∞</text>
                        </g>
                    </svg>

                    <div style="text-align: center;">
                        <div style="font-size: 2em; font-weight: bold; color: #4CAF50;" id="compass-heading">0¬∞</div>
                        <div style="font-size: 0.9em; opacity: 0.7;">Boat's Perspective</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üéÆ Manual Control</h2>
                <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 15px;">
                    Use arrow keys or buttons to move the boat
                </p>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 200px; margin: 0 auto;">
                    <div></div>
                    <button class="btn-mode" onclick="moveBoat('north')" style="font-size: 20px;">‚¨Ü</button>
                    <div></div>
                    <button class="btn-mode" onclick="moveBoat('west')" style="font-size: 20px;">‚¨Ö</button>
                    <button class="btn-mode" onclick="moveBoat('stop')" style="font-size: 14px;">‚èπ</button>
                    <button class="btn-mode" onclick="moveBoat('east')" style="font-size: 20px;">‚û°</button>
                    <div></div>
                    <button class="btn-mode" onclick="moveBoat('south')" style="font-size: 20px;">‚¨á</button>
                    <div></div>
                </div>
                <label style="margin-top: 15px;">Movement Speed (m/s):</label>
                <input type="number" id="manual-speed" value="2.0" step="0.5" min="0.5" max="10">
            </div>
        </div>

        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">
            <div class="card" style="min-height: 280px; display: flex; flex-direction: column;">
                <h2>üìç Starting Position</h2>
                <label>Select Location:</label>
                <select id="start-location" style="width: 100%; padding: 8px; margin: 10px 0; border-radius: 5px; background: #2a2a2a; color: white; border: 1px solid #444;">
                    <option value="current">üåê Current Location (Browser)</option>
                    <option value="30.0245,-90.034533">‚öì New Orleans Port</option>
                    <option value="38.9784,-76.4810">‚öì Annapolis Port</option>
                    <option value="33.7506,-118.1937">‚öì Long Beach Port</option>
                    <option value="33.7365,-118.2725">‚öì Los Angeles Port</option>
                    <option value="47.2663,-122.3811">‚öì Tacoma Port</option>
                    <option value="25.7823,-80.1331">‚öì Miami Port</option>
                </select>
                <button class="btn-mode" onclick="setStartingPosition()" style="width: 100%; margin-top: 5px;">Apply Position</button>
                <div id="location-status" style="font-size: 0.9em; opacity: 0.8; margin-top: 10px;"></div>
            </div>

            <div class="card" style="min-height: 280px; display: flex; flex-direction: column;">
                <h2>Simulation Mode</h2>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <button class="btn-mode active" onclick="setMode('stationary', event)">üìç Stationary</button>
                    <button class="btn-mode" onclick="setMode('drift', event)">‚û°Ô∏è Drift</button>
                    <button class="btn-mode" onclick="setMode('anchoring', event)">‚öì Anchoring</button>
                    <button class="btn-mode" id="route-mode-btn" onclick="setMode('waypoint', event)" disabled title="Upload and activate a route first">üó∫Ô∏è Route</button>
                </div>

                <div id="drift-controls" style="display: none; margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Drift Settings</h3>
                    <label>Speed (m/s):</label>
                    <input type="number" id="drift-speed" value="0.5" step="0.1" min="0" max="10">
                    <label>Course (degrees):</label>
                    <input type="number" id="drift-course" value="0" step="1" min="0" max="359">
                    <button class="btn-mode" onclick="applyDrift()">Apply Drift</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üì° NMEA Data Stream</h2>
            <div style="background: rgba(0,0,0,0.4); padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 13px; max-height: 200px; overflow-y: auto;">
                <div id="nmea-output" style="color: #4CAF50;"></div>
            </div>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                üì∂ Live NMEA 0183 sentences ‚Ä¢ Broadcasting on TCP:10110 and UDP:2000
            </p>
        </div>

        <div class="card">
            <h2>üß≠ Route Management</h2>
            <div style="margin-bottom: 15px;">
                <label>Upload GPX Route:</label>
                <input type="file" id="gpx-file" accept=".gpx,.kml,.csv" style="margin: 10px 0;">
                <button class="btn-mode" onclick="uploadRoute()">Upload Route</button>
            </div>
            <div id="route-list" style="margin: 15px 0;">
                <h3 style="font-size: 1.1em; margin-bottom: 10px;">Available Routes:</h3>
                <div id="routes" style="font-size: 0.9em;"></div>
            </div>
            <div id="route-controls" style="display: none; margin-top: 15px;">
                <h3 style="font-size: 1.1em; margin-bottom: 10px;">Route Playback:</h3>
                <div class="info-row">
                    <span class="label">Current Waypoint:</span>
                    <span class="value" id="current-waypoint">-</span>
                </div>
                <label>Playback Speed (knots):</label>
                <input type="number" id="route-speed" value="5.0" step="0.5" min="0.5" max="20">
                <button class="btn-start" onclick="startRoute()">‚ñ∂ Start Route</button>
                <button class="btn-stop" onclick="stopRoute()">‚èπ Stop Route</button>
            </div>
        </div>

        <!-- Hardware Status Panel -->
        <div class="card">
            <h2>‚öôÔ∏è Hardware Status (from LVGL UI)</h2>
            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-top: 20px;">

                <!-- Mute Button -->
                <div style="text-align: center; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <button id="hw-mute-btn" class="btn-mode" style="width: 100%; font-size: 16px; padding: 15px;" onclick="toggleMute()">
                        üîá MUTE
                    </button>
                    <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.7;">Status</div>
                    <div id="mute-status" style="font-weight: bold; color: #888;">OFF</div>
                </div>

                <!-- Buzzer Indicator -->
                <div style="text-align: center; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="font-size: 1.2em; margin-bottom: 10px;">üîä Buzzer</div>
                    <div id="buzzer-led" style="width: 60px; height: 60px; margin: 10px auto; background: #333; border-radius: 50%; border: 3px solid #555; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);"></div>
                    <div style="font-size: 0.9em; opacity: 0.7;">Status</div>
                    <div id="buzzer-status" style="font-weight: bold; color: #888;">OFF</div>
                </div>

                <!-- Relay with Light -->
                <div style="text-align: center; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="font-size: 1.2em; margin-bottom: 10px;">üîå Relay</div>
                    <div style="position: relative; width: 60px; height: 60px; margin: 10px auto;">
                        <div id="relay-light" style="width: 100%; height: 100%; background: #333; border-radius: 10px; border: 3px solid #555; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);"></div>
                        <div id="relay-light-glow" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30px; height: 30px; background: #666; border-radius: 50%; transition: all 0.3s;"></div>
                    </div>
                    <div style="font-size: 0.9em; opacity: 0.7;">Light</div>
                    <div id="relay-status" style="font-weight: bold; color: #888;">OFF</div>
                </div>

                <!-- Alarm Panel -->
                <div style="text-align: center; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="font-size: 1.2em; margin-bottom: 10px;">üö® Alarm Panel</div>
                    <div id="alarm-led" style="width: 60px; height: 60px; margin: 10px auto; background: #333; border-radius: 50%; border: 3px solid #555; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);"></div>
                    <div style="font-size: 0.9em; opacity: 0.7;">Pull to Ground</div>
                    <div id="alarm-status" style="font-weight: bold; color: #888;">OFF</div>
                </div>

                <!-- Anchor Alert Panel (Black Square) -->
                <div style="text-align: center; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    <div style="font-size: 1.0em; margin-bottom: 10px;">Anchor Alert</div>
                    <div style="width: 70px; height: 70px; margin: 5px auto; background: #000; border: 2px solid #444; border-radius: 5px; display: flex; align-items: center; justify-content: center;">
                        <div id="anchor-alert-led" style="width: 30px; height: 30px; background: #333; border-radius: 50%; border: 2px solid #555; box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);"></div>
                    </div>
                    <div id="anchor-alert-status" style="font-weight: bold; color: #888; font-size: 0.9em; margin-top: 5px;">OFF</div>
                </div>

            </div>
            <p style="margin-top: 15px; font-size: 0.85em; opacity: 0.6; text-align: center;">
                Hardware outputs controlled by LVGL UI Simulator
            </p>
        </div>

        <div class="card">
            <h2>üó∫Ô∏è Position Map</h2>
            <div id="map"></div>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                üìç Red marker shows current GPS position ‚Ä¢ Click map to set new position
            </p>
        </div>

        <!-- Anchor Widgets Row: Side-by-side layout -->
        <div class="anchor-widgets-row" id="anchor-widgets-container" style="display: none;">
            <div class="card" id="anchor-visualization-widget">
                <h2>‚öì Anchor Visualization</h2>
                <canvas id="anchor-canvas" width="400" height="400" style="border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;"></canvas>
                <div id="anchor-status" style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <div>
                        <span style="opacity: 0.7;">Distance from Anchor:</span>
                        <span id="anchor-dist" style="font-weight: bold; color: #4CAF50;">--</span> m
                    </div>
                    <div>
                        <span style="opacity: 0.7;">Phase:</span>
                        <span id="anchor-phase" style="font-weight: bold; color: #2196F3;">--</span>
                    </div>
                </div>
            </div>

            <div class="card" id="anchor-analysis-widget">
                <h2>üìä Anchor Drag Analysis</h2>
                <canvas id="analysis-canvas" width="400" height="400" style="border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; background: rgba(0,0,0,0.3);"></canvas>
                <div id="analysis-stats" style="margin-top: 15px; font-size: 0.9em;">
                    <div style="margin-bottom: 8px;">
                        <span style="opacity: 0.7;">GPS Points Collected:</span>
                        <span id="analysis-points" style="font-weight: bold; color: #2196F3;">0</span>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <span style="opacity: 0.7;">Calculated Anchor:</span>
                        <span id="analysis-anchor" style="font-weight: bold; color: #FFC107;">Calculating...</span>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <span style="opacity: 0.7;">Swing Radius:</span>
                        <span id="analysis-radius" style="font-weight: bold; color: #4CAF50;">-- m</span>
                    </div>
                    <div>
                        <span style="opacity: 0.7;">Distance to Calculated Anchor:</span>
                        <span id="analysis-distance" style="font-weight: bold; color: #FF5722;">-- m</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let map = null;
        let marker = null;
        let positionCircle = null;
        let nmeaLines = [];
        let routeLayer = null;
        let currentRoute = null;

        // Initialize Leaflet map
        function initMap(lat, lon) {
            if (map) return; // Already initialized

            map = L.map('map').setView([lat, lon], 13);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 19
            }).addTo(map);

            // Add custom marker (ship icon)
            const shipIcon = L.divIcon({
                html: 'üö¢',
                className: 'ship-marker',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });

            marker = L.marker([lat, lon], { icon: shipIcon }).addTo(map);
            marker.bindPopup(`<b>GPS Position</b><br>Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}`);

            // Add position accuracy circle
            positionCircle = L.circle([lat, lon], {
                color: '#2196F3',
                fillColor: '#2196F3',
                fillOpacity: 0.1,
                radius: 50 // meters
            }).addTo(map);

            // Add custom "Center on Boat" control
            L.Control.CenterBoat = L.Control.extend({
                onAdd: function(map) {
                    const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                    container.innerHTML = '<button title="Center on Boat" style="padding: 5px 10px; font-size: 14px; background: white; border: none; cursor: pointer; display: flex; align-items: center; gap: 5px;"><span style="font-size: 16px;">üö¢</span><span>Center</span></button>';
                    container.onclick = function() {
                        if (marker) {
                            const pos = marker.getLatLng();
                            map.setView(pos, map.getZoom());
                        }
                    };
                    return container;
                },
                onRemove: function(map) {
                    // Nothing to do here
                }
            });

            L.control.centerBoat = function(opts) {
                return new L.Control.CenterBoat(opts);
            };

            L.control.centerBoat({ position: 'topleft' }).addTo(map);

            // Click map to set new position
            map.on('click', function(e) {
                const newLat = e.latlng.lat;
                const newLon = e.latlng.lng;

                if (confirm(`Set new position to:\nLat: ${newLat.toFixed(6)}\nLon: ${newLon.toFixed(6)}`)) {
                    setPosition(newLat, newLon);
                }
            });
        }

        // Update marker position on map
        function updateMapPosition(lat, lon) {
            if (!map) {
                initMap(lat, lon);
            } else {
                if (marker && positionCircle) {
                    marker.setLatLng([lat, lon]);
                    positionCircle.setLatLng([lat, lon]);
                    marker.setPopupContent(`<b>GPS Position</b><br>Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}`);

                    // Force map to refresh
                    map.invalidateSize();

                    // Keep position in view
                    if (!map.getBounds().contains([lat, lon])) {
                        map.setView([lat, lon], map.getZoom());
                    }
                }
            }
        }

        // Update compass visualization
        function updateCompass(course, windSpeed, windDirection) {
            const compassRose = document.getElementById('compass-rose');
            const headingText = document.getElementById('compass-heading');

            // Normalize course to 0-359 degrees
            course = ((course % 360) + 360) % 360;

            if (compassRose && headingText) {
                // Rotate the compass rose to show heading
                // Course is in degrees, rotate counter-clockwise from north
                compassRose.style.transform = `rotate(${course}deg)`;

                // Update heading text
                headingText.textContent = Math.round(course) + '¬∞';

                // Update color based on cardinal direction
                const cardinals = [
                    { name: 'N', min: 337.5, max: 22.5, color: '#ff4444' },
                    { name: 'E', min: 67.5, max: 112.5, color: '#4CAF50' },
                    { name: 'S', min: 157.5, max: 202.5, color: '#2196F3' },
                    { name: 'W', min: 247.5, max: 292.5, color: '#FFC107' }
                ];

                let color = '#4CAF50'; // default
                for (const cardinal of cardinals) {
                    if (cardinal.name === 'N') {
                        if (course >= cardinal.min || course <= cardinal.max) {
                            color = cardinal.color;
                            break;
                        }
                    } else {
                        if (course >= cardinal.min && course <= cardinal.max) {
                            color = cardinal.color;
                            break;
                        }
                    }
                }
                headingText.style.color = color;
            }

            // Update wind data on outer ring
            if (windSpeed !== undefined && windDirection !== undefined) {
                const twsValue = document.getElementById('tws-value');
                const windAngleValue = document.getElementById('wind-angle-value');
                const windArc = document.getElementById('wind-arc');
                const windArrowTip = document.getElementById('wind-arrow-tip');

                if (twsValue) {
                    twsValue.textContent = windSpeed.toFixed(1);
                }

                if (windAngleValue) {
                    windAngleValue.textContent = Math.round(windDirection) + '¬∞';
                }

                // Draw wind direction arc from north (0¬∞) to wind direction
                if (windArc && windArrowTip && windSpeed > 0) {
                    const centerX = 120;
                    const centerY = 120;
                    const radius = 110;

                    // Convert wind direction to radians
                    const windRad = (windDirection - 90) * Math.PI / 180; // -90 to start from north

                    // Calculate arc endpoint
                    const endX = centerX + radius * Math.cos(windRad);
                    const endY = centerY + radius * Math.sin(windRad);

                    // Create arc path (from north to wind direction)
                    const startAngle = -90; // North in SVG coordinates
                    const endAngle = windDirection - 90;
                    const largeArcFlag = Math.abs(endAngle - startAngle) > 180 ? 1 : 0;

                    const startX = centerX + radius * Math.cos(startAngle * Math.PI / 180);
                    const startY = centerY + radius * Math.sin(startAngle * Math.PI / 180);

                    windArc.setAttribute('d', `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY}`);

                    // Position arrow tip at wind direction
                    windArrowTip.setAttribute('cx', endX);
                    windArrowTip.setAttribute('cy', endY);
                } else if (windArc && windSpeed === 0) {
                    // Hide arc when no wind
                    windArc.setAttribute('d', '');
                }
            }
        }

        // Set new position via API
        function setPosition(lat, lon) {
            fetch('/api/position', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ latitude: lat, longitude: lon })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Position updated');
                    updateStatus();
                }
            })
            .catch(err => console.error('Failed to set position:', err));
        }

        // Generate NMEA GPGGA sentence from GPS data
        function generateNMEASentence(data) {
            // Convert decimal degrees to NMEA format (DDMM.MMMM)
            function toNMEA(degrees, isLat) {
                const abs = Math.abs(degrees);
                const deg = Math.floor(abs);
                const min = (abs - deg) * 60;
                const formatted = (deg * 100 + min).toFixed(4).padStart(isLat ? 9 : 10, '0');
                return formatted;
            }

            const latStr = toNMEA(data.latitude, true);
            const latDir = data.latitude >= 0 ? 'N' : 'S';
            const lonStr = toNMEA(data.longitude, false);
            const lonDir = data.longitude >= 0 ? 'E' : 'W';

            const now = new Date();
            const utcTime = now.getUTCHours().toString().padStart(2, '0') +
                           now.getUTCMinutes().toString().padStart(2, '0') +
                           now.getUTCSeconds().toString().padStart(2, '0') + '.00';

            const sentence = `GPGGA,${utcTime},${latStr},${latDir},${lonStr},${lonDir},1,08,1.0,${data.altitude.toFixed(1)},M,0.0,M,,`;

            // Calculate checksum
            let checksum = 0;
            for (let i = 0; i < sentence.length; i++) {
                checksum ^= sentence.charCodeAt(i);
            }

            return `$${sentence}*${checksum.toString(16).toUpperCase().padStart(2, '0')}`;
        }

        socket.on('connect', () => {
            console.log('Connected to simulator');
            updateStatus();
        });

        socket.on('gps_update', (data) => {
            document.getElementById('lat').textContent = data.latitude.toFixed(6);
            document.getElementById('lon').textContent = data.longitude.toFixed(6);
            document.getElementById('speed').textContent = data.speed.toFixed(2) + ' m/s';
            document.getElementById('course').textContent = data.course.toFixed(1) + '¬∞';

            // Update compass (wind data will be updated by updateStatus)
            updateCompass(data.course);

            // Update map position
            updateMapPosition(data.latitude, data.longitude);

            // Use NMEA sentence from backend if available, otherwise generate
            const timestamp = new Date().toISOString().substr(11, 8);
            const nmeaSentence = data.nmea || generateNMEASentence(data);

            // Add to display (newest first, limit to 10 rows)
            nmeaLines.unshift(`[${timestamp}] ${nmeaSentence}`);
            if (nmeaLines.length > 10) nmeaLines.pop();

            document.getElementById('nmea-output').innerHTML =
                nmeaLines.map(line => `<div>${line}</div>`).join('');
        });

        socket.on('status', (data) => {
            const statusEl = document.getElementById('status');
            statusEl.textContent = data.running ? 'RUNNING' : 'STOPPED';
            statusEl.className = 'status ' + (data.running ? 'running' : 'stopped');
        });

        function updateStatus() {
            fetch('/api/status')
                .then(r => r.json())
                .then(data => {
                    const statusEl = document.getElementById('status');
                    statusEl.textContent = data.running ? 'RUNNING' : 'STOPPED';
                    statusEl.className = 'status ' + (data.running ? 'running' : 'stopped');

                    document.getElementById('lat').textContent = data.position.latitude.toFixed(6);
                    document.getElementById('lon').textContent = data.position.longitude.toFixed(6);
                    document.getElementById('speed').textContent = data.position.speed.toFixed(2) + ' m/s';
                    document.getElementById('course').textContent = data.position.course.toFixed(1) + '¬∞';

                    // Update wind display
                    if (data.wind) {
                        document.getElementById('wind-speed').textContent = data.wind.speed.toFixed(1) + ' kts';
                        document.getElementById('wind-dir').textContent = data.wind.direction.toFixed(0) + '¬∞';
                        document.getElementById('wind-speed-input').value = data.wind.speed;
                        document.getElementById('wind-dir-input').value = data.wind.direction;

                        // Update compass with wind data
                        updateCompass(data.position.course, data.wind.speed, data.wind.direction);
                    } else {
                        // Update compass without wind data
                        updateCompass(data.position.course, 0, 0);
                    }

                    document.getElementById('udp-port').textContent = data.network.udp_port;
                    document.getElementById('tcp-port').textContent = data.network.tcp_port;
                    document.getElementById('tcp-clients').textContent = data.network.tcp_clients;

                    // Initialize or update map
                    updateMapPosition(data.position.latitude, data.position.longitude);
                });
        }

        function startSimulator() {
            fetch('/api/start', { method: 'POST' })
                .then(r => r.json())
                .then(() => updateStatus());
        }

        function stopSimulator() {
            fetch('/api/stop', { method: 'POST' })
                .then(r => r.json())
                .then(() => updateStatus());
        }

        function resetSimulator() {
            if (confirm('Reset simulator to initial state? This will:\n‚Ä¢ Stop the simulator\n‚Ä¢ Return to starting position\n‚Ä¢ Clear all modes\n‚Ä¢ Reset wind to 0\n‚Ä¢ Clear routes')) {
                fetch('/api/reset', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.status === 'reset') {
                            // Update UI to reflect reset state
                            updateStatus();
                            loadSettings();
                            loadRoutes();

                            // Clear mode buttons
                            document.querySelectorAll('.btn-mode').forEach(btn => {
                                btn.classList.remove('active');
                            });

                            // Re-center map on starting position
                            if (map && marker) {
                                const pos = marker.getLatLng();
                                map.setView(pos, 13);
                            }

                            alert('Simulator reset to initial state');
                        }
                    })
                    .catch(err => alert('Failed to reset simulator: ' + err));
            }
        }

        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.style.display = (panel.style.display === 'none') ? 'block' : 'none';
        }

        function updateRateDisplay() {
            const slider = document.getElementById('update-rate-slider');
            const display = document.getElementById('update-rate-display');
            display.textContent = parseFloat(slider.value).toFixed(1) + ' Hz';
        }

        function applySettings() {
            const updateRate = parseFloat(document.getElementById('update-rate-slider').value);
            const anchorRodeDistance = parseFloat(document.getElementById('anchor-rode-distance').value);

            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    update_rate: updateRate,
                    anchor_rode_distance: anchorRodeDistance
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    alert('Error: ' + data.error);
                } else {
                    alert(`Settings updated!\nUpdate Rate: ${data.update_rate} Hz\nAnchor Rode Distance: ${data.anchor_rode_distance} m`);
                    updateStatus(); // Refresh status display
                    updateAnchorVisualization(); // Refresh anchor widget if visible
                }
            })
            .catch(err => alert('Failed to update settings: ' + err));
        }

        function loadSettings() {
            fetch('/api/settings')
                .then(r => r.json())
                .then(data => {
                    document.getElementById('update-rate-slider').value = data.update_rate;
                    updateRateDisplay();
                    if (data.anchor_rode_distance !== undefined) {
                        document.getElementById('anchor-rode-distance').value = data.anchor_rode_distance;
                    }
                });
        }

        function showAnchoringComingSoon(event) {
            alert('‚öì Anchoring Mode - Coming Soon!\n\nAnchoring simulation parameters will be defined and implemented in a future update.');
            // Don't change mode, keep current mode active
        }

        function setMode(mode, event) {
            fetch('/api/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: mode })
            })
            .then(r => r.json())
            .then(data => {
                // Remove active class from all mode buttons
                document.querySelectorAll('.btn-mode').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Add active class to the clicked button
                if (event && event.target) {
                    event.target.classList.add('active');
                }

                // Show/hide drift controls
                document.getElementById('drift-controls').style.display =
                    (mode === 'drift') ? 'block' : 'none';

                // Update wind inputs if wind was auto-set (anchoring or drift mode with no wind)
                if (data.wind) {
                    document.getElementById('wind-speed-input').value = data.wind.speed;
                    document.getElementById('wind-dir-input').value = data.wind.direction;
                    document.getElementById('wind-speed').textContent = data.wind.speed.toFixed(1) + ' kts';
                    document.getElementById('wind-dir').textContent = data.wind.direction.toFixed(0) + '¬∞';
                    console.log(`Wind auto-set to ${data.wind.speed} kts @ ${data.wind.direction}¬∞`);
                }

                // Update position display to show mode change
                console.log(`Mode changed to: ${mode}`);
            });
        }

        function applyDrift() {
            const speed = parseFloat(document.getElementById('drift-speed').value);
            const course = parseFloat(document.getElementById('drift-course').value);

            fetch('/api/drift', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ speed: speed, course: course })
            });
        }

        function applyWind() {
            const speed = parseFloat(document.getElementById('wind-speed-input').value);
            const direction = parseFloat(document.getElementById('wind-dir-input').value);

            fetch('/api/wind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ speed: speed, direction: direction })
            })
            .then(r => r.json())
            .then(data => {
                document.getElementById('wind-speed').textContent = data.speed.toFixed(1) + ' kts';
                document.getElementById('wind-dir').textContent = data.direction.toFixed(0) + '¬∞';

                // Update drift widget visibility based on wind speed
                updateDriftWidgetVisibility(data.speed);
            });
        }

        function updateDriftWidgetVisibility(windSpeed) {
            const driftWidget = document.getElementById('drift-settings-widget');
            if (windSpeed === 0 || windSpeed === null) {
                // No wind - show drift settings
                driftWidget.style.display = 'block';
            } else {
                // Wind present - hide drift settings
                driftWidget.style.display = 'none';
            }
        }

        function applyManualDrift() {
            const direction = parseFloat(document.getElementById('manual-drift-dir').value);
            const speed = parseFloat(document.getElementById('manual-drift-speed').value);

            if (speed <= 0) {
                alert('Drift speed must be greater than 0');
                return;
            }

            fetch('/api/drift/manual', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    direction: direction,
                    speed: speed
                })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    document.getElementById('drift-status').textContent =
                        `${speed.toFixed(1)} kts @ ${direction}¬∞`;
                    alert(`Manual drift set:\n${speed.toFixed(1)} kts to ${getDirectionName(direction)}`);
                }
            })
            .catch(err => alert('Failed to set drift: ' + err));
        }

        function getDirectionName(degrees) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                              'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        function toggleVariableWind() {
            const enabled = document.getElementById('variable-wind').checked;

            fetch('/api/wind/variable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            })
            .then(r => r.json())
            .then(data => {
                console.log(`Variable wind ${data.enabled ? 'enabled' : 'disabled'}`);
            });
        }

        function moveBoat(direction) {
            const speed = parseFloat(document.getElementById('manual-speed').value);

            // Direction to course mapping (degrees)
            const courseMap = {
                'north': 0,
                'east': 90,
                'south': 180,
                'west': 270,
                'stop': null
            };

            const course = courseMap[direction];

            if (course === null) {
                // Stop movement - set to stationary mode
                setMode('stationary');
                return;
            }

            // Set drift mode with manual direction
            fetch('/api/drift', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ speed: speed, course: course })
            });

            // Switch to drift mode
            fetch('/api/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'drift' })
            });
        }

        // Keyboard controls for arrow keys
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                'ArrowUp': 'north',
                'ArrowDown': 'south',
                'ArrowLeft': 'west',
                'ArrowRight': 'east',
                'Escape': 'stop'
            };

            if (keyMap[e.key]) {
                e.preventDefault();
                moveBoat(keyMap[e.key]);
            }
        });

        // Starting position function
        function setStartingPosition() {
            const select = document.getElementById('start-location');
            const value = select.value;
            const statusDiv = document.getElementById('location-status');

            if (value === 'current') {
                // Use browser geolocation
                statusDiv.textContent = 'üìç Requesting location...';
                statusDiv.style.color = '#ff9800';

                if (!navigator.geolocation) {
                    statusDiv.textContent = '‚ùå Geolocation not supported';
                    statusDiv.style.color = '#f44336';
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;

                        fetch('/api/position', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ latitude: lat, longitude: lon })
                        })
                        .then(r => r.json())
                        .then(() => {
                            statusDiv.textContent = `‚úì Position set to ${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                            statusDiv.style.color = '#4caf50';
                            updateMapPosition(lat, lon);
                            map.setView([lat, lon], 13);
                        });
                    },
                    (error) => {
                        statusDiv.textContent = `‚ùå ${error.message}`;
                        statusDiv.style.color = '#f44336';
                    },
                    { enableHighAccuracy: true, timeout: 10000 }
                );
            } else {
                // Use predefined location
                const [lat, lon] = value.split(',').map(parseFloat);

                fetch('/api/position', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latitude: lat, longitude: lon })
                })
                .then(r => r.json())
                .then(() => {
                    const locationName = select.options[select.selectedIndex].text.replace('‚öì ', '');
                    statusDiv.textContent = `‚úì Position set to ${locationName}`;
                    statusDiv.style.color = '#4caf50';
                    updateMapPosition(lat, lon);
                    map.setView([lat, lon], 13);
                });
            }
        }

        // Route management functions
        function uploadRoute() {
            const fileInput = document.getElementById('gpx-file');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a GPX file to upload');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            fetch('/api/route/upload', {
                method: 'POST',
                body: formData
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    alert(`Route "${data.route.name}" uploaded successfully with ${data.route.waypoint_count} waypoints`);
                    loadRoutes();
                    fileInput.value = '';
                } else {
                    alert(`Upload failed: ${data.error || 'Unknown error'}`);
                }
            })
            .catch(err => {
                console.error('Upload error:', err);
                alert('Failed to upload route');
            });
        }

        function loadRoutes() {
            fetch('/api/route/list')
                .then(r => r.json())
                .then(data => {
                    const routesDiv = document.getElementById('routes');
                    const routeBtn = document.getElementById('route-mode-btn');

                    if (data.routes.length === 0) {
                        routesDiv.innerHTML = '<p style="opacity: 0.6;">No routes uploaded</p>';
                        routeBtn.disabled = true;
                        routeBtn.title = 'Upload and activate a route first';
                    } else {
                        routesDiv.innerHTML = data.routes.map(route =>
                            `<div style="background: rgba(0,0,0,0.2); padding: 10px; margin: 5px 0; border-radius: 5px;">
                                <strong>${route.name}</strong> (${route.waypoint_count} waypoints)
                                <button class="btn-mode" style="margin-left: 10px; padding: 5px 10px;" onclick="activateRoute('${route.id}')">Activate</button>
                            </div>`
                        ).join('');
                        // Don't auto-enable - only enable when route is activated
                    }
                });
        }

        function activateRoute(routeId) {
            fetch(`/api/route/activate/${routeId}`, {
                method: 'POST'
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    currentRoute = data.route;
                    document.getElementById('route-controls').style.display = 'block';
                    document.getElementById('route-mode-btn').disabled = false;
                    document.getElementById('route-mode-btn').title = 'Route mode: Follow uploaded route';
                    visualizeRoute(data.route);
                    alert(`Route "${data.route.name}" activated`);
                }
            });
        }

        function visualizeRoute(route) {
            // Remove existing route layer
            if (routeLayer) {
                map.removeLayer(routeLayer);
            }

            // Create route line and waypoint markers
            const waypoints = route.waypoints.map(wp => [wp.lat, wp.lon]);

            routeLayer = L.layerGroup();

            // Draw route line
            L.polyline(waypoints, {
                color: '#ff9800',
                weight: 3,
                opacity: 0.7
            }).addTo(routeLayer);

            // Add waypoint markers
            route.waypoints.forEach((wp, idx) => {
                L.circleMarker([wp.lat, wp.lon], {
                    radius: 6,
                    fillColor: '#ff9800',
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                })
                .bindPopup(`<b>Waypoint ${idx + 1}</b><br>${wp.name || 'Unnamed'}<br>Lat: ${wp.lat.toFixed(6)}<br>Lon: ${wp.lon.toFixed(6)}`)
                .addTo(routeLayer);
            });

            routeLayer.addTo(map);

            // Fit map to route bounds
            const bounds = L.latLngBounds(waypoints);
            map.fitBounds(bounds, { padding: [50, 50] });
        }

        function startRoute() {
            const speedKnots = parseFloat(document.getElementById('route-speed').value);
            const speedMs = speedKnots * 0.514444;  // Convert knots to m/s

            fetch('/api/route/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ speed: speedMs })
            })
            .then(r => r.json())
            .then(data => {
                if (data.status === 'success') {
                    setMode('waypoint');
                }
            });
        }

        function stopRoute() {
            fetch('/api/route/stop', { method: 'POST' })
                .then(r => r.json())
                .then(() => {
                    setMode('stationary');
                    document.getElementById('current-waypoint').textContent = '-';
                });
        }

        // Anchor Visualization Functions
        function drawAnchorVisualization(anchorData) {
            const canvas = document.getElementById('anchor-canvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Check if we're in drift mode with a saved anchor
            const inDriftMode = anchorData.mode === 'drift' && anchorData.saved_anchor_position;

            if (!anchorData.anchor_position && !inDriftMode) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '16px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Activate Anchoring Mode to see visualization', centerX, centerY);
                return;
            }

            const METERS_PER_DEGREE_LAT = 111320.0;
            const metersPerDegreeLon = 111320.0 * Math.cos(anchorData.boat_position[0] * Math.PI / 180);

            // Calculate scale - must include boat position for proper display
            const rodeDistance = anchorData.rode_distance;
            let displayRadius = rodeDistance;

            // In drift mode with saved anchor, show both original and dragged anchor position
            if (inDriftMode) {
                // Original anchor position (saved)
                const origAnchorLat = anchorData.saved_anchor_position[0];
                const origAnchorLon = anchorData.saved_anchor_position[1];
                const boatLat = anchorData.boat_position[0];
                const boatLon = anchorData.boat_position[1];

                // Calculate drift offset from original anchor
                const driftLat = (boatLat - origAnchorLat) * METERS_PER_DEGREE_LAT;
                const driftLon = (boatLon - origAnchorLon) * metersPerDegreeLon;
                const driftDistance = Math.sqrt(driftLat * driftLat + driftLon * driftLon);

                // Scale to fit both rode circle and drifted position
                displayRadius = Math.max(rodeDistance, driftDistance * 1.2);
            }

            // Calculate scale based on display radius
            const scale = (canvas.width * 0.4) / displayRadius;

            if (inDriftMode) {
                // Recalculate drift distance for positioning (now that we have scale)
                const origAnchorLat = anchorData.saved_anchor_position[0];
                const origAnchorLon = anchorData.saved_anchor_position[1];
                const boatLat = anchorData.boat_position[0];
                const boatLon = anchorData.boat_position[1];
                const driftLat = (boatLat - origAnchorLat) * METERS_PER_DEGREE_LAT;
                const driftLon = (boatLon - origAnchorLon) * metersPerDegreeLon;
                const driftDistance = Math.sqrt(driftLat * driftLat + driftLon * driftLon);

                // Position original anchor at left side of canvas, dragged anchor at right
                const origAnchorX = centerX - driftDistance * scale * 0.5;
                const origAnchorY = centerY;

                // Draw ORIGINAL anchor (gray/faded)
                ctx.beginPath();
                ctx.arc(origAnchorX, origAnchorY, rodeDistance * scale, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = 'rgba(200, 200, 200, 0.6)';
                ctx.font = '12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${rodeDistance}m`, origAnchorX, origAnchorY - rodeDistance * scale - 10);
                ctx.fillText('ORIGINAL', origAnchorX, origAnchorY - rodeDistance * scale - 25);

                ctx.font = '24px system-ui';
                ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚öì', origAnchorX, origAnchorY);

                // Calculate dragged anchor position (anchor moved with boat)
                const draggedAnchorX = origAnchorX + driftDistance * scale;
                const draggedAnchorY = origAnchorY;

                // Draw DRAGGED anchor (cyan/blue)
                ctx.beginPath();
                ctx.arc(draggedAnchorX, draggedAnchorY, rodeDistance * scale, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(0, 191, 255, 0.4)';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = 'rgba(0, 191, 255, 0.7)';
                ctx.font = '12px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${rodeDistance}m`, draggedAnchorX, draggedAnchorY - rodeDistance * scale - 10);
                ctx.fillText('DRAGGED', draggedAnchorX, draggedAnchorY - rodeDistance * scale - 25);

                ctx.font = '24px system-ui';
                ctx.fillStyle = '#00BFFF';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚öì', draggedAnchorX, draggedAnchorY);

                // Draw boat at relative position on dragged anchor circle
                const boatX = draggedAnchorX;
                const boatY = draggedAnchorY - rodeDistance * scale * 0.8;

                ctx.font = '24px system-ui';
                ctx.fillStyle = '#4CAF50';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üö¢', boatX, boatY);

                // Draw line from dragged anchor to boat
                ctx.beginPath();
                ctx.moveTo(draggedAnchorX, draggedAnchorY);
                ctx.lineTo(boatX, boatY);
                ctx.strokeStyle = 'rgba(0, 191, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw drift arrow from original to dragged anchor
                ctx.beginPath();
                ctx.moveTo(origAnchorX, origAnchorY);
                ctx.lineTo(draggedAnchorX, draggedAnchorY);
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.setLineDash([10, 5]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw arrowhead
                const arrowSize = 10;
                const angle = Math.atan2(draggedAnchorY - origAnchorY, draggedAnchorX - origAnchorX);
                ctx.beginPath();
                ctx.moveTo(draggedAnchorX, draggedAnchorY);
                ctx.lineTo(
                    draggedAnchorX - arrowSize * Math.cos(angle - Math.PI / 6),
                    draggedAnchorY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(draggedAnchorX, draggedAnchorY);
                ctx.lineTo(
                    draggedAnchorX - arrowSize * Math.cos(angle + Math.PI / 6),
                    draggedAnchorY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Display drift distance
                ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.font = '14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Anchor Drag: ${driftDistance.toFixed(1)}m`, centerX, centerY + rodeDistance * scale + 30);

                // Draw wind arrow for drift mode
                if (anchorData.wind && anchorData.wind.speed > 0) {
                    const windSpeed = anchorData.wind.speed;
                    const windDir = anchorData.wind.direction * Math.PI / 180;

                    const arrowLength = Math.min(windSpeed * 3, 60);
                    const arrowX = 50;
                    const arrowY = 50;

                    ctx.save();
                    ctx.translate(arrowX, arrowY);
                    ctx.rotate(windDir);

                    // Arrow shaft
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, arrowLength);
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(0, arrowLength);
                    ctx.lineTo(-5, arrowLength - 10);
                    ctx.lineTo(5, arrowLength - 10);
                    ctx.closePath();
                    ctx.fillStyle = '#2196F3';
                    ctx.fill();

                    ctx.restore();

                    // Wind label
                    ctx.fillStyle = 'rgba(33, 150, 243, 0.8)';
                    ctx.font = '12px system-ui';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${windSpeed.toFixed(1)} kts`, 70, 50);
                    ctx.fillText(`${anchorData.wind.direction}¬∞`, 70, 65);
                }

                return; // Early return for drift mode
            }

            // Normal anchoring mode visualization
            // Draw rode distance circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, rodeDistance * scale, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw distance label on circle
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '12px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${rodeDistance}m`, centerX, centerY - rodeDistance * scale - 10);

            // Draw anchor at center
            ctx.font = '24px system-ui';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öì', centerX, centerY);

            // Calculate boat position relative to anchor
            if (anchorData.anchor_position && anchorData.boat_position) {
                const anchorLat = anchorData.anchor_position[0];
                const anchorLon = anchorData.anchor_position[1];
                const boatLat = anchorData.boat_position[0];
                const boatLon = anchorData.boat_position[1];

                // Convert lat/lon offset to pixels
                const METERS_PER_DEGREE_LAT = 111320.0;
                const metersPerDegreeLon = 111320.0 * Math.cos(anchorLat * Math.PI / 180);

                const dLat = (boatLat - anchorLat) * METERS_PER_DEGREE_LAT;
                const dLon = (boatLon - anchorLon) * metersPerDegreeLon;

                const boatX = centerX + dLon * scale;
                const boatY = centerY - dLat * scale;

                // Draw trail
                if (anchorData.trail && anchorData.trail.length > 0) {
                    anchorData.trail.forEach((point, i) => {
                        const pLat = point[0];
                        const pLon = point[1];
                        const pDLat = (pLat - anchorLat) * METERS_PER_DEGREE_LAT;
                        const pDLon = (pLon - anchorLon) * metersPerDegreeLon;
                        const pX = centerX + pDLon * scale;
                        const pY = centerY - pDLat * scale;

                        const alpha = 0.2 + (i / anchorData.trail.length) * 0.6;
                        ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(pX, pY, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }

                // Draw boat
                const dist = anchorData.current_distance;
                const boatColor = dist > rodeDistance * 0.9 ? '#FF9800' : '#4CAF50';
                ctx.font = '24px system-ui';
                ctx.fillStyle = boatColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üö¢', boatX, boatY);

                // Draw line from anchor to boat
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(boatX, boatY);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw wind arrow
            if (anchorData.wind && anchorData.wind.speed > 0) {
                const windSpeed = anchorData.wind.speed;
                const windDir = anchorData.wind.direction * Math.PI / 180;

                const arrowLength = Math.min(windSpeed * 3, 60);
                const arrowX = 50;
                const arrowY = 50;

                ctx.save();
                ctx.translate(arrowX, arrowY);
                ctx.rotate(windDir);

                // Arrow shaft
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, arrowLength);
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, arrowLength);
                ctx.lineTo(-5, arrowLength - 10);
                ctx.lineTo(5, arrowLength - 10);
                ctx.closePath();
                ctx.fillStyle = '#2196F3';
                ctx.fill();

                ctx.restore();

                // Wind label
                ctx.fillStyle = 'rgba(33, 150, 243, 0.8)';
                ctx.font = '12px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText(`${windSpeed.toFixed(1)} kts`, 70, 50);
                ctx.fillText(`${anchorData.wind.direction}¬∞`, 70, 65);
            }
        }

        function updateAnchorVisualization() {
            fetch('/api/anchor/state')
                .then(r => r.json())
                .then(data => {
                    // Show widget if anchoring is active OR if in drift mode with saved anchor
                    const showWidget = data.phase !== 'idle' || (data.mode === 'drift' && data.saved_anchor_position);

                    if (showWidget) {
                        document.getElementById('anchor-widgets-container').style.display = 'grid';
                        drawAnchorVisualization(data);
                        drawAnchorAnalysis(data);

                        // Update status text
                        if (data.mode === 'drift' && data.saved_anchor_position) {
                            document.getElementById('anchor-dist').textContent = 'DRIFT';
                            document.getElementById('anchor-phase').textContent = 'drift mode';
                        } else {
                            document.getElementById('anchor-dist').textContent = data.current_distance.toFixed(1);
                            document.getElementById('anchor-phase').textContent = data.phase;
                        }

                        // Color code distance
                        const distSpan = document.getElementById('anchor-dist');
                        if (data.mode === 'drift') {
                            distSpan.style.color = '#FFA500';  // Orange for drift
                        } else if (data.current_distance > data.rode_distance * 0.9) {
                            distSpan.style.color = '#FF9800';
                        } else {
                            distSpan.style.color = '#4CAF50';
                        }
                    } else {
                        document.getElementById('anchor-widgets-container').style.display = 'none';
                    }
                })
                .catch(err => console.log('Anchor state fetch error:', err));
        }

        // Draw scatter plot analysis of anchor swing
        function drawAnchorAnalysis(anchorData) {
            const canvas = document.getElementById('analysis-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update statistics
            document.getElementById('analysis-points').textContent = anchorData.trail.length;

            if (!anchorData.calculated_anchor || anchorData.trail.length < 10) {
                // Not enough points yet
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Collecting GPS points...', centerX, centerY);
                ctx.fillText(`${anchorData.trail.length} / 10 minimum`, centerX, centerY + 20);

                document.getElementById('analysis-anchor').textContent = 'Calculating...';
                document.getElementById('analysis-radius').textContent = '-- m';
                document.getElementById('analysis-distance').textContent = '-- m';
                return;
            }

            // We have enough points - calculate scale
            const calc = anchorData.calculated_anchor;
            const boatLat = anchorData.boat_position[0];
            const boatLon = anchorData.boat_position[1];

            // Update statistics
            document.getElementById('analysis-anchor').textContent =
                `(${calc.center_lat.toFixed(6)}, ${calc.center_lon.toFixed(6)})`;
            document.getElementById('analysis-radius').textContent =
                `${calc.radius_m.toFixed(1)} m (${calc.radius_ft.toFixed(1)} ft)`;

            // Calculate distance from boat to calculated anchor
            const dlat = Math.abs(boatLat - calc.center_lat) * 111320;
            const dlon = Math.abs(boatLon - calc.center_lon) * 111320 * Math.cos(calc.center_lat * Math.PI / 180);
            const distToCalc = Math.sqrt(dlat * dlat + dlon * dlon);
            document.getElementById('analysis-distance').textContent = `${distToCalc.toFixed(1)} m`;

            // Determine scale - use rode distance as fixed reference
            // Circle shows maximum swing radius, but scale is based on rode distance to keep visualization stable
            const rodeDistance = anchorData.rode_distance;
            const displayRadius = Math.max(calc.radius_m, rodeDistance * 0.8);  // Use larger of calc radius or 80% of rode
            const scale = (Math.min(canvas.width, canvas.height) * 0.8) / (2 * displayRadius);  // 80% of canvas for margin

            // Helper function to convert lat/lon to canvas coordinates
            function latLonToCanvas(lat, lon) {
                const dy = (lat - calc.center_lat) * 111320;  // meters
                const dx = (lon - calc.center_lon) * 111320 * Math.cos(calc.center_lat * Math.PI / 180);
                return {
                    x: centerX + dx * scale,
                    y: centerY - dy * scale  // Invert Y for canvas coordinates
                };
            }

            // Draw swing radius circle
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, calc.radius_m * scale, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw radius label on the outside of the circle
            ctx.fillStyle = 'rgba(76, 175, 80, 0.9)';
            ctx.font = 'bold 14px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            const radiusText = `${calc.radius_m.toFixed(1)}m (${calc.radius_ft.toFixed(0)}ft)`;
            ctx.fillText(radiusText, centerX, centerY - calc.radius_m * scale - 5);

            // Draw calculated anchor position (center)
            ctx.fillStyle = '#FFC107';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw cross on calculated anchor
            ctx.strokeStyle = '#FFC107';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 10, centerY);
            ctx.lineTo(centerX + 10, centerY);
            ctx.moveTo(centerX, centerY - 10);
            ctx.lineTo(centerX, centerY + 10);
            ctx.stroke();

            // Draw GPS trail points as scatter plot
            ctx.fillStyle = 'rgba(33, 150, 243, 0.6)';
            for (const [lat, lon] of anchorData.trail) {
                const pos = latLonToCanvas(lat, lon);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw current boat position (larger, different color)
            const boatPos = latLonToCanvas(boatLat, boatLon);
            ctx.fillStyle = '#FF5722';
            ctx.beginPath();
            ctx.arc(boatPos.x, boatPos.y, 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw actual anchor position (if different from calculated)
            if (anchorData.anchor_position) {
                const anchorPos = latLonToCanvas(anchorData.anchor_position[0], anchorData.anchor_position[1]);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚öì', anchorPos.x, anchorPos.y + 7);
            }

            // Draw legend
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('‚öì Actual Anchor', 10, 20);
            ctx.fillStyle = '#FFC107';
            ctx.fillText('+ Calculated Anchor', 10, 35);
            ctx.fillStyle = 'rgba(33, 150, 243, 0.8)';
            ctx.fillText('‚Ä¢ GPS Trail', 10, 50);
            ctx.fillStyle = '#FF5722';
            ctx.fillText('‚óè Current Position', 10, 65);
        }

        // Hardware Status Functions
        function updateHardwareStatus() {
            fetch('/api/hardware/status')
                .then(r => r.json())
                .then(data => {
                    // Update buzzer LED
                    const buzzerLed = document.getElementById('buzzer-led');
                    const buzzerStatus = document.getElementById('buzzer-status');
                    if (data.buzzer_active) {
                        buzzerLed.style.background = '#ff4444';
                        buzzerLed.style.boxShadow = '0 0 20px #ff4444, inset 0 2px 5px rgba(0,0,0,0.5)';
                        buzzerStatus.textContent = 'ON';
                        buzzerStatus.style.color = '#ff4444';
                    } else {
                        buzzerLed.style.background = '#333';
                        buzzerLed.style.boxShadow = 'inset 0 2px 5px rgba(0,0,0,0.5)';
                        buzzerStatus.textContent = 'OFF';
                        buzzerStatus.style.color = '#888';
                    }

                    // Update relay light
                    const relayGlow = document.getElementById('relay-light-glow');
                    const relayStatus = document.getElementById('relay-status');
                    if (data.relay_active) {
                        relayGlow.style.background = '#ffeb3b';
                        relayGlow.style.boxShadow = '0 0 30px #ffeb3b';
                        relayStatus.textContent = 'ON';
                        relayStatus.style.color = '#ffeb3b';
                    } else {
                        relayGlow.style.background = '#666';
                        relayGlow.style.boxShadow = 'none';
                        relayStatus.textContent = 'OFF';
                        relayStatus.style.color = '#888';
                    }

                    // Update alarm LED
                    const alarmLed = document.getElementById('alarm-led');
                    const alarmStatus = document.getElementById('alarm-status');
                    if (data.alarm_active) {
                        alarmLed.style.background = '#ff4444';
                        alarmLed.style.boxShadow = '0 0 20px #ff4444, inset 0 2px 5px rgba(0,0,0,0.5)';
                        alarmStatus.textContent = 'ACTIVE';
                        alarmStatus.style.color = '#ff4444';
                    } else {
                        alarmLed.style.background = '#333';
                        alarmLed.style.boxShadow = 'inset 0 2px 5px rgba(0,0,0,0.5)';
                        alarmStatus.textContent = 'OFF';
                        alarmStatus.style.color = '#888';
                    }

                    // Update anchor alert LED
                    const anchorAlertLed = document.getElementById('anchor-alert-led');
                    const anchorAlertStatus = document.getElementById('anchor-alert-status');
                    if (data.anchor_alert_active) {
                        anchorAlertLed.style.background = '#ff9800';
                        anchorAlertLed.style.boxShadow = '0 0 20px #ff9800, inset 0 2px 5px rgba(0,0,0,0.5)';
                        anchorAlertStatus.textContent = 'ALERT';
                        anchorAlertStatus.style.color = '#ff9800';
                    } else {
                        anchorAlertLed.style.background = '#333';
                        anchorAlertLed.style.boxShadow = 'inset 0 2px 5px rgba(0,0,0,0.5)';
                        anchorAlertStatus.textContent = 'OFF';
                        anchorAlertStatus.style.color = '#888';
                    }

                    // Update mute button state
                    const muteBtn = document.getElementById('hw-mute-btn');
                    const muteStatus = document.getElementById('mute-status');
                    if (data.mute_active) {
                        muteBtn.classList.add('active');
                        muteStatus.textContent = 'ON';
                        muteStatus.style.color = '#ff9800';
                    } else {
                        muteBtn.classList.remove('active');
                        muteStatus.textContent = 'OFF';
                        muteStatus.style.color = '#888';
                    }

                    // Update LED state display (for debugging)
                    if (data.led_state !== undefined) {
                        const ledStateNames = ['OFF', 'RED', 'YELLOW', 'GREEN', 'BLINKING_RED'];
                        console.log(`LED State: ${ledStateNames[data.led_state] || data.led_state}`);
                    }
                })
                .catch(err => {
                    // Silently fail if endpoint not available yet
                    console.log('Hardware status not available:', err.message);
                });
        }

        function toggleMute() {
            fetch('/api/hardware/mute', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            })
            .then(r => r.json())
            .then(data => {
                console.log('Mute toggled:', data);
                updateHardwareStatus();
            })
            .catch(err => {
                console.error('Failed to toggle mute:', err);
                alert('Mute control not yet implemented on backend');
            });
        }

        // Update anchor visualization every second when in anchoring mode
        setInterval(updateAnchorVisualization, 1000);

        // Update hardware status every second
        setInterval(updateHardwareStatus, 1000);

        // Update status every 5 seconds
        setInterval(updateStatus, 5000);
        setInterval(loadRoutes, 10000);  // Refresh route list
        updateStatus();
        loadRoutes();
        loadSettings();  // Load current settings on page load
        updateHardwareStatus();  // Initial hardware status fetch

        // Set hostname dynamically
        document.getElementById('hostname').textContent = window.location.hostname || 'localhost';
    </script>
</body>
</html>
